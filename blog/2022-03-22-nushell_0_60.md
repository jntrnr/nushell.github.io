---
title: Nushell 0.60
author: The Nu Authors
author_site: https://twitter.com/nu_shell
author_image: https://www.nushell.sh/blog/images/nu_logo.png
excerpt: Today, we're releasing version 0.60 of Nu. This is an enormous release, with lots of changes across all aspects of Nushell.
---

TODO:
  - animation gif?
  - fill out custom completions section
  - document def-env and scoped `cd`
  - document parallelism and `par-each`
  - document `extern`
  - more typechecking
  - engine and storing spans
  - faster parsing, faster engine
  - correct variable captures
  - add screenshot for lscolors support
  - document breaking changes
  - default params/flags
  - add peoples names who worked on various parts
  - or... thank everyone who worked on this release
- reedline
  * entirely new keybinding system
- $env.PROMPT_COMMAND and $env.PROMPT_COMMAND_RIGHT with block or string
- $env.LAST_EXIT_CODE
- size of binaries down 10x
- scoped cd
- ability to page data with ls + less
- $env.LS_COLORS
- footers in tables
- maybe a list of new commands
  * columns
  * complete
  * decode
  * def-env
  * env
  * export, export def, export env
  * extern
  * fmt
  * group
  * grid, as in, alias lsg = ls | grid -c
  * gstat plugin
  * ignore
  * keybindings default, keybindings listen, keybindings list
  * module
  * nu-highlight
  * par-each
  * print
  * register
  * transpose
  * use
  * window
  * view-source

# Nushell 0.60

Nushell, or Nu for short, is a new shell that takes a modern, structured approach to your commandline. It works seamlessly with the data from your filesystem, operating system, and a growing number of file formats to make it easy to build powerful commandline pipelines.

Today, we're releasing a beta release of 0.60 of Nu. This is an enormous release, with lots of changes across all aspects of Nushell.

<!-- more -->

# Where to get it

Nu 0.60 is available as [pre-built binaries](https://github.com/nushell/nushell/releases/tag/0.60.0) or from [crates.io](https://crates.io/crates/nu). If you have Rust installed you can install it using `cargo install nu`.

If you want all the built-in goodies, you can install `cargo install nu --all-features`.

As part of this release, we also publish a set of optional plugins you can install and use with Nu. To install, use `cargo install nu_plugin_<plugin name>`.

# Party! ðŸ¥³

It's here! ðŸŽ‰ðŸŽ‰

We're excited to announce the first full release of Nushell using the new engine, new line editor, and so much more. In this blog post, we'll detail the new capabilities.

# Jumping versions

The first thing you'll notice is that we're jumping from version 0.44 to 0.60. This is on purpose, you didn't miss anything.

Because of the number of changes, and the number of breaking changes, we wanted to let everyone know how much had changed by also making a big jump in the version number. Previous scripts will need to be updated, and you'll need to learn some of the new ways of doing things in Nushell to get back to your same level of comfort.

Let's talk about the features new in this release.

# Custom completions

Let's not bury the lede. The long-awaited, long-requested feature of having nice completions for external commands is finally here.

# A new config file

With 0.60, we've moved away from the .toml style of config to a config built from a Nushell script. We've found this to be both more intuitive and much easier to work with.

When you first start up Nushell, you'll be asked if you'd like to create a default config file. This is a great way to see the new defaults and to change them to meet your needs. You'll also see some examples in how to modify the stylings, prompt, keybindings, and external completions.

# Language improvements

There's quite a list of changes to the language itself. Let's talk about each one to help you transition to the new Nushell:

## if, meet else

Previously, you'd write:

```
> if $x < 3 { echo "true!" } { echo "false" }
```

This not only felt inelegant, but was prone to errors as people would want to leave off the second block when they didn't need it or just naturally want to type `else`.

This led to a new concept in Nushell: the keyword shape. Shapes in Nushell are a way for commands to tell the parser what the shape of their parameters are. In turn, the parser will use this knowledge to parse the arguments before they're given to the command (and also to do completions and early errors). With this, `else` is now one of the new keyword shapes, allowing it to take an expression that follows.

Taken together, we can now not only write the above like this:

```
if $x < 3 {
  echo $true
} else {
  echo $false
}
```

But we can also string together multiple if/else:

```
if $x < 3 {
  echo "less than three"
} else if $x < 10 {
  echo "less than ten
} else {
  echo "something else!"
}
```

## Shortcircuiting conditions

Boolean operators `&&` and `||` now will properly shortcircuit, only evaluating the right hand side if necessary.

## Escape characters in strings

With 0.60, Nushell now divides strings into two types: strings with escape characters and strings without. The first one case is written with double-quotes (`"`) and the second case is written with single-quotes (`'`):

```
> "hello\world"
hello
world
> 'hello\nworld'
hello\nworld
```

Nushell will prefer the single-quotes for things like path names that include spaces, allowing you to naturally write paths for Windows as well.

The difference in double-quoted and single-quoted strings also extends to interpolated strings (`$""` and `$''`):

```
> let x = 100
> $"value is:\n($x)"
value is:
100
> $'value is:\n($x)'
value is:\n100
```

## New value forms

The 0.60 release also brings with it a number of new value forms.

### Records

You now can write a record, or a list of key/value pairs, as a native data type in Nushell:

```
> {name: "Bob", age: 10}
â•­â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â•®
â”‚ name â”‚ Bob â”‚
â”‚ age  â”‚ 10  â”‚
â•°â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â•¯
```

### Table as a list of records

With the introduction of records, a second way to define a table is a list (or stream) of records:
```
> seq 3 | each { |x| { name: Bob, x: $x } }
  #   name   x
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  0   Bob    1
  1   Bob    2
  2   Bob    3
```

### Integers are now signed 64-bit integers

We're moving away from the 'bigint' style of integers, so now integers are always signed 64-bit ints.

### Decimals are now signed 64-bit floats

Likewise, we're moving away from 'bigdecimal' to signed 64-bit float values.

### Dates

Earlier versions of Nushell supported dates as a value type, but they lacked a way to write them. You can now write a date literal in one of three ways:

```
# As a date
> 2022-02-02

# As a date and time, assuming UTC
> 2022-02-23T19:47:47

# As a date and time, with a timezone
2022-02-23T19:47:47.888239621-05:00
```

These come from the [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) standard for datetime formats.

### Binary data

Like dates, earlier versions of Nushell also supported binary data but there was no way to write a binary data literal. You're now able to write them using the `0x[...]` form:

```
> 0x[11 ff]
Length: 2 (0x2) bytes | printable whitespace ascii_other non_ascii
00000000:   11 ff                                                â€¢Ã—
```

Spaces and commas are optional in this form, letting you separate write them however is best for readability.

### Custom values

Another form we'll be talking about more as it grows is the "custom value" form. These are value types that you can extend the current set with by implementing a trait in Rust and registering the type.

The dataframe support in 0.60 uses this feature.

## New built-in values

We're introducing `true` and `false` as builtin values. These represent their boolean values true and false respectively.

## Better binary data support

You can now use `get`, `skip`, and `first` on binary data to reach the bytes you'd like to work with. We're exploring extending this further so that it becomes easier to explore your binary data just like your text data.

## Structured environment

Inside of Nu, the environment can now hold any kind of structured value. For example, opening the `PATH` environment variable now might look like in macOS:

```
> $env.PATH
â•­â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ 0 â”‚ /opt/homebrew/opt/openssl@3/bin â”‚
â”‚ 1 â”‚ /opt/homebrew/bin               â”‚
â”‚ 2 â”‚ /opt/homebrew/sbin              â”‚
â”‚ 3 â”‚ /usr/local/bin                  â”‚
â”‚ 4 â”‚ /usr/bin                        â”‚
â”‚ 5 â”‚ /bin                            â”‚
â”‚ 6 â”‚ /usr/sbin                       â”‚
â”‚ 7 â”‚ /sbin                           â”‚
â•°â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

This allows you to more easily add and update to the environment. For example, we can add a new entry to the PATH:

```
> let-env PATH = ($env.path | prepend '/my/path')
```

Environment variables that aren't strings can be converted to strings automatically using the new `ENV_CONVERSIONS` environment variable.

## More consistent tables and cell paths

With this release, we've simplified the commands for working with tables. The two fundamental commands are now: `select` and `get`.

### `Select`-ing data

The `select` command allows you to keep the structure of what you're working on and reduce it to only the part you want. For example, just as before you can pass `select` to get a column:

```
> ls | select name
â•­â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ #  â”‚       name        â”‚
â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  0 â”‚ CNAME             â”‚
â”‚  1 â”‚ CONTRIBUTING.md   â”‚
â”‚  2 â”‚ LICENSE           â”‚
â”‚  3 â”‚ README.md         â”‚
â”‚  4 â”‚ assets            â”‚
â”‚  5 â”‚ blog              â”‚
...
```

You can now also use `select` on rows, by passing in a row number:

```
> ls | select 1
â•­â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ # â”‚      name       â”‚ type â”‚ size  â”‚  modified  â”‚
â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0 â”‚ CONTRIBUTING.md â”‚ file â”‚ 389 B â”‚ 2 days ago â”‚
â•°â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

### `Get`-ing data

The other fundamental command for working with tables is `get`. Like `select`, `get` allows you to work with columns and rows in a table, or fields in a record. Unlike `select`, the `get` command extracts data out of the table and does not try to preserve its original form. This is helpful when you want to get at the cell data itself.

Via a column:
```
> ls | get name
â•­â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  0 â”‚ CNAME             â”‚
â”‚  1 â”‚ CONTRIBUTING.md   â”‚
â”‚  2 â”‚ LICENSE           â”‚
â”‚  3 â”‚ README.md         â”‚
â”‚  4 â”‚ assets            â”‚
â”‚  5 â”‚ blog              â”‚
...
```

Via a row:
```
> ls | get 1
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ name     â”‚ CONTRIBUTING.md â”‚
â”‚ type     â”‚ file            â”‚
â”‚ size     â”‚ 389 B           â”‚
â”‚ modified â”‚ 2 days ago      â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

You'll notice that getting rows out of a table with columns gives you back a record. You can think of a table as a list of records.

You can combine working with rows and columns together into a "cell path", a way of reaching the data you want. If we only wanted to get the cell's data in row 1, column "size", we can do:

```
> ls | get size.1
```

## New pipeline form

When writing scripts in Nushell, often folks want to be able to build up a pipeline and line up all the pipes on the left. This is now supported:

```
ls
| where size > 10kb
| length
```

## Stdout, stderr, and exit codes

In previous versions of Nushell, you generally had easy access to the stdout of an external command. You could run it, and then create a pipe and work with its output. If you wanted to work with stderr or get its exit code, you didn't have an easy way to do it.

With 0.60, we've introduced the `complete` command. Running an external command and then pipeline it to `complete` runs the external to completion and then gives you the stdout, stderr, and exit code of that external.

```
> cat CNAME | complete
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ stdout    â”‚ www.nushell.sh â”‚
â”‚ stderr    â”‚                â”‚
â”‚ exit_code â”‚ 0              â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

## Modules

With 0.60, you're now able to create your own modules, allowing you to grow to larger projects with clean interfaces between files. A module can be written either using the `module` keyword:

```
module greetings {
  export def greet [] {
    print "hello!"
  }
}

use greetings greet
greet
```

You can also make modules from whole files. We can rewrite the above using a separate file:

```
# greetings.nu
export def greet [] {
  print "hello!"
}

# main.nu
use greetings.nu greet
greet
```

Modules allow you to `export` custom commands and environment variables to be used in other places.

## Make your own errors

You can also create your own error messages in your custom commands and send these back to the user if they call your command in the wrong way. For example, let's say you wanted to require that the user pass in a value between 1 and 10:

```
> def one-to-ten [x: int] {
    let span = (metadata $x).span
    if $x > 10 || $x < 1 {
      error make {
        msg: "Value not between 1 and 10",
        label: {
          text: "expected a value between 1 and 10",
          start: $span.start,
          end: $span.end
        }
      }
    } else {
      $"passed ($x)"
    }
  }
> one-to-ten 6
passed 6
> one-to-ten 21
Error:
  Ã— Value too large
   â•­â”€[entry #47:1:1]
 1 â”‚ one-to-ten 21
   Â·            â”€â”¬
   Â·             â•°â”€â”€ expected a value between 1 and 10
   â•°â”€â”€â”€â”€
```

# Shell improvements

## Bang bang and more

You can now use `!!` to run the previous command, or `!` followed by the row number in the `history` you'd like to run again.

We're working to bring the [book up to date](https://www.nushell.sh/book/), and it's a good place to find explanations of these improvements. Be sure to also look at the [updated command documentation](https://www.nushell.sh/book/command_reference.html) for more information on the updated commands.

## Better multiline editing

With the switch to reedline, you can also get better feedback when working on multiline edits. For example, moving to the next line, you'll now see `:::` by default preceding the extended input:

```
> do {
::: echo "hello"
::: echo "world"
::: }
hello
world
```

(You can configure the `:::` default value by setting the `PROMPT_MULTILINE_INDICATOR` environment variable)

## Miette

We're moving to a new error reporter called [miette](https://github.com/zkat/miette). It's an attractive way of showing errors back while you're working in the REPL or on scripts.

```
> 10 / "bob"
Error: nu::parser::unsupported_operation (link)

  Ã— Types mismatched for operation.
   â•­â”€[entry #39:1:1]
 1 â”‚ 10 / "bob"
   Â· â”€â”¬ â”¬ â”€â”€â”¬â”€â”€
   Â·  â”‚ â”‚   â•°â”€â”€ string
   Â·  â”‚ â•°â”€â”€ doesn't support these values.
   Â·  â•°â”€â”€ int
   â•°â”€â”€â”€â”€
  help: Change int or string to be the right types and try again.
```

# Reedline

Nushell has changed its line editor and now it uses [Reedline](https://github.com/nushell/reedline). This new line
editor allows for improvements and added functionality to the already awesome Nushell experience. Some of the
new improvements are:

## Completions menus

![Commands menu](../assets/images/0_60_0_completions_internal.gif)

Do you want to search for commands using a menu? Nushell has you covered.
Press tab and a completion menu will appear with options for you to select. Based on the context different
options will be available to you

## History menu

![History menu](../assets/images/0_60_0_history.gif)

Your shell history can be easily accessed as well via menus. Using ctrl-x, you can search for a
history item or you could just simply navigate the menu until you find what you are looking for.

You can also use the history menu to compose a pipe with smaller pipes you have used before.

![History complete](../assets/images/0_60_0_history_complete.gif)

## New Commands

| category | command |
| -------- | ------- |
| conversions | into {bool, datetime, duration} |
| core | def-env, error make |
| core | export_def_env, export_def, export env, export |
| core | extern, hide, metadata  |
| core | ignore, mod, module, register, use, view-source |
| env | let_env, load_env, with-env |
| experimental | view_source |
| filters | columns, group, par-each, transpose, window |
| formats | nuon |
| math | reducers |
| plugins | gstat |
| strings | decode, nu-highlight, print |
| system | complete |
| viewers | grid |

## New Keybindings

Now you can define complex keybindings for nushell. For example, say you have changed your config file and
want to reload it in your nushell session. You can create a special keybinding to help reload your config file:

```
{
    name: reload_config
    modifier: none
    keycode: f5
    mode: emacs
    event: [
        { edit: { cmd: clear } }
        { edit: { cmd: insertString value: $"source '($nu.config-path)'" } }
        { send: Enter }
    ]
}
```

with this keybinding every time you press F5 you config file is sourced and ready to go. Neat!


# Introducing 'nuon'

As the syntax for Nushell has continued to grow and evolved, we noticed that writing data in Nushell was kinda fun. The more we played with it, the more the idea grew that we could create a data file format using the Nushell syntax for data. Thus, 'nuon' was born. With it, we now include `from nuon` and `to nuon` to help you work with the new .nuon files.

Nuon is a superset of JSON, allowing you to pass JSON files and parse them as nuon. Additionally, Nuon supports the data forms from Nushell, including compact tables, durations, filesizes, and more.

```
# sample.nuon
[
    # The nuon compact table format
    [[a, nuon, table]; [1, 2, 3], [4, 5, 6]],

    # A filesize
    100kib,

    # A duration
    100sec

    # A boolean
    true,

    # A record
    {name: "Bobby", age: 99}

    # Binary data
    0x[11, ff, ee, 1f]
]
```

Nuon is still very much experimental, but we're already enjoying using it and are eager to continue to improve on it.

# New Engine



# New plugin architecture

Rather that scanning for all new plugins on startup like we did with 0.44 (and taking ages to start Nu), the new `register` command stores the
location and signature of your plugins, making it easier to load at start up.

```
> register -e capnp ~/.cargo/bin/nu_plugin_extra_query
```

Also, the new plugin architecture is now multi-protocol, allowing you to pick the right protocol for your plugin. We currently support json and capnp.

By the way, you are not limited to write plugins in Rust. You can even create a python script and use it as a Nushell plugin. You only need to
specify what command should be used to run the plugin

```
> register -e json -s python ~/my_plugins/plugin.py
```


# Looking ahead
